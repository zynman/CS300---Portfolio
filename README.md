# CS300---Portfolio

Problem: The problem I was solving involved sorting bids using data structures and algorithms.

Approach: To approach this problem, I decided to choose appropriate data structures and sorting algorithms based on the characteristics of the bids and the specific sorting requirements. I considered using data structures like arrays, linked lists, heaps, and sorting algorithms such as merge sort, quicksort, or even specialized algorithms like radix sort. Understanding the properties and time complexities of these data structures and algorithms was crucial for making informed decisions.

Importance of Data Structures: I realized that data structures are vital because they determine how efficiently I can perform operations like insertion, deletion, and searching in my program. In the context of sorting bids, selecting the right data structure significantly impacted the efficiency of my sorting process.

Overcoming Roadblocks: During the project, I encountered challenges. Overcoming these challenges involved researching and learning about different data structures and algorithms, testing and profiling my code, and iterating on my implementation to improve its performance.

Expanding Approach: Working on this project expanded my approach to designing software. I gained exposure to various sorting algorithms and their trade-offs. I learned how to choose the best algorithm for a specific scenario and how to analyze and compare their time and space complexities.

Evolution of Programming Style: This project evolved the way I write programs. I understood the importance of code readability, modularity, and maintainability. When dealing with data structures and algorithms, I learned that clear and organized code is essential for others (and my future self) to understand, modify, and maintain the codebase.

Conclusion: Implementing data structures and algorithms to sort bids not only taught me the technical aspects of sorting but also provided valuable experience in decision-making, optimization, and writing maintainable code. These skills are transferable to various software development scenarios, helping me become a more effective and proficient programmer.
